
import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
from matplotlib import pyplot as plt
#import cv2
import numpy as np
import time
from mpl_toolkits.mplot3d import axes3d
device = 'cuda' if torch.cuda.is_available() else 'cpu'

X = torch.FloatTensor([[0, 0], [0, 1], [1, 0], [1, 1]]).to(device)
Y = torch.FloatTensor([[0], [1], [1], [0]]).to(device)
#XX1=torch.FloatTensor(5)-torch.rand(5,2)
#YY1=torch.FloatTensor(5)-torch.rand(5,2)

#XX2=torch.
count=0
X_train=torch.FloatTensor([[-4,4]])
Y_train=torch.FloatTensor([1])
#--------------------------------------
while True :
    X_temp=torch.FloatTensor([1,1])+6*torch.rand(1,2)
    print(X_temp)
    if((X_temp[0,0]-4)*(X_temp[0,0]-4)+(X_temp[0,1]-4)*(X_temp[0,1]-4)<9):
        X_train=torch.cat([X_train,X_temp],dim=0)
        Y_train=torch.cat([Y_train, torch.FloatTensor([0])],dim=0)
        count=count+1
        print(count)
        if(count==100):
            count = 0
            break


while True :
    X_temp=torch.FloatTensor([-6,-6])+6*torch.rand(1,2)
    print(X_temp)
    if((X_temp[0,0]+3)*(X_temp[0,0]+3)+(X_temp[0,1]+3)*(X_temp[0,1]+3)<9):
        X_train=torch.cat([X_train,X_temp],dim=0)
        Y_train=torch.cat([Y_train, torch.FloatTensor([0])],dim=0)
        count=count+1
        print(count)
        if(count==100):
            count = 0
            break

while True:
    X_temp = torch.FloatTensor([1, -1])+torch.rand(1, 2)*torch.FloatTensor([6,-6])
    print(X_temp)
    if ((X_temp[0,0] - 4) * (X_temp[0,0] - 4) + (X_temp[0,1] + 4) * (X_temp[0,1] + 4) < 9):
        X_train = torch.cat([X_train, X_temp], dim=0)
        Y_train = torch.cat([Y_train, torch.FloatTensor([0])], dim=0)
        count = count + 1
        print(count)
        if (count == 100):
            count = 0
            break



while True:
    X_temp = torch.FloatTensor([-1, 1])+torch.rand(1, 2)*torch.FloatTensor([-6,6])
    print(X_temp)
    if ((X_temp[0,0] + 4) * (X_temp[0,0] + 4) + (X_temp[0,1] - 4) * (X_temp[0,1] - 4) < 9):
        X_train = torch.cat([X_train, X_temp], dim=0)
        Y_train = torch.cat([Y_train, torch.FloatTensor([0])], dim=0)
        count = count + 1
        print(count)
        if (count == 99):
            count = 0
            break
while True:
    X_temp = torch.FloatTensor([-2,-2])+6*torch.rand(1,2)
    print(X_temp)
    if ((X_temp[0,0] -1) * (X_temp[0,0] -1) + (X_temp[0,1] - 1) * (X_temp[0,1] - 1) < 9):
        X_train = torch.cat([X_train, X_temp], dim=0)
        Y_train = torch.cat([Y_train, torch.FloatTensor([1])], dim=0)
        count = count + 1
        if (count == 100):
            count = 0
            break

a1=torch.Tensor.numpy(X_train[:,0])
a2=torch.Tensor.numpy(X_train[:,1])

plt.scatter(a1[:399],a2[:399],color='red')
plt.scatter(a1[400:499],a2[400:499],color='green')
plt.show()


#--------------------------------------
linear1 = torch.nn.Linear(2, 4, bias=True)
linear2 = torch.nn.Linear(4, 1, bias=True)
#linear3 = torch.nn.Linear(3, 1, bias=True)



#linear3 = torch.nn.Linear(3, 1, bias=True)
#linear3 = torch.nn.Linear(2, 1, bias=True)

sigmoid = torch.nn.Sigmoid()

model = torch.nn.Sequential(linear1,sigmoid,linear2,sigmoid).to(device)

criterion = torch.nn.BCELoss().to(device)
optimizer = torch.optim.SGD(model.parameters(), lr=1)
XX = np.arange(-6.5, 7.8, 1.3)
YY = np.arange(-6.5, 7.8, 1.3)
ZZ = np.zeros((11, 11))
AA = np.concatenate((XX, YY), axis=0)

XXX, YYY = np.meshgrid(XX, YY)
for step in range(10001):
    optimizer.zero_grad()
    hypothesis = model(X_train)

    # cost/loss function
    cost = criterion(hypothesis, Y_train)
    cost.backward()
    optimizer.step()

    if step % 100 == 0:
        #print(step, cost.item())

        with torch.no_grad():
            for X_ in range(11):
                for Y_ in range(11):
                    ZZ[X_, Y_] = torch.Tensor.numpy(
                        model(torch.from_numpy(np.array([XXX[X_, Y_], YYY[X_, Y_]], dtype='f'))))
                    # print(ZZ[X_,Y_])




            h = plt.contour(XX, YY, ZZ, colors='black', linestyles='dashed', linewidths=1)
            plt.clabel(h, inline=1, fontsize=10)
            h = plt.contourf(XX, YY, ZZ)
            plt.xlabel('X1')
            plt.xlabel('X2')
            plt.draw()
            a1 = torch.Tensor.numpy(X_train[:, 0])
            a2 = torch.Tensor.numpy(X_train[:, 1])

            plt.scatter(a1[:399], a2[:399], color='red')
            plt.scatter(a1[400:499], a2[400:499], color='green')
            plt.pause(0.1)
            plt.clf()





# for reproducibility
torch.manual_seed(777)
if device == 'cuda':
    torch.cuda.manual_seed_all(777)

for param in model.parameters():
    print(param.data)

b=np.array([[3,2,2],[1,1,1],[2,2,2]])
with torch.no_grad():
    hypothesis = model(X)
    predicted = (hypothesis > 0.5).float()
    accuracy = (predicted == Y).float().mean()

    X_test=torch.FloatTensor([[0,0],[1,0],[0.5,0.5]])
    hypothesis2=torch.Tensor.numpy(model(X_test))
    print("[0, 0] : ",hypothesis2[0],"\n[1,0] : ",hypothesis2[1],"\n[0.5, 0.5] : ",hypothesis2[2])


    print('\nHypothesis: ', hypothesis.detach().cpu().numpy(), '\nCorrect: ',
          predicted.detach().cpu().numpy(), '\nAccuracy: ', accuracy.item())









    #cm=plt.cm.get_cmap('viridis')
    #plt.scatter(XXX,YYY,c=ZZ,cmap=cm)
    #plt.show()



    #print(ZZ)
