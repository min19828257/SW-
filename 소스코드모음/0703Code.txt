
import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
from matplotlib import pyplot as plt
#import cv2
import numpy as np
import time
from mpl_toolkits.mplot3d import axes3d
device = 'cuda' if torch.cuda.is_available() else 'cpu'

X = torch.FloatTensor([[0, 0], [0, 1], [1, 0], [1, 1]]).to(device)
Y = torch.FloatTensor([[0], [1], [1], [0]]).to(device)
#XX1=torch.FloatTensor(5)-torch.rand(5,2)
#YY1=torch.FloatTensor(5)-torch.rand(5,2)

#XX2=torch.rand(5,2)-torch.Float

linear1 = torch.nn.Linear(2, 2, bias=True)
linear2 = torch.nn.Linear(2, 2, bias=True)
linear3 = torch.nn.Linear(2, 2, bias=True)
linear4 = torch.nn.Linear(2, 2, bias=True)
linear5 = torch.nn.Linear(2, 2, bias=True)
linear6 = torch.nn.Linear(2, 1, bias=True)

#linear3 = torch.nn.Linear(3, 1, bias=True)
#linear3 = torch.nn.Linear(2, 1, bias=True)

sigmoid = torch.nn.Sigmoid()

model = torch.nn.Sequential(linear1,sigmoid,linear2,sigmoid,linear3,sigmoid,linear4,sigmoid,linear5,sigmoid,linear6,sigmoid).to(device)

criterion = torch.nn.BCELoss().to(device)
optimizer = torch.optim.SGD(model.parameters(), lr=1)
XX = np.arange(0, 1.1, 0.1)
YY = np.arange(0, 1.1, 0.1)
ZZ = np.zeros((11, 11))
AA = np.concatenate((XX, YY), axis=0)

XXX, YYY = np.meshgrid(XX, YY)
for step in range(10001):
    optimizer.zero_grad()
    hypothesis = model(X)

    # cost/loss function
    cost = criterion(hypothesis, Y)
    cost.backward()
    optimizer.step()

    if step % 100 == 0:
        #print(step, cost.item())

        with torch.no_grad():
            for X_ in range(11):
                for Y_ in range(11):
                    ZZ[X_, Y_] = torch.Tensor.numpy(
                        model(torch.from_numpy(np.array([XXX[X_, Y_], YYY[X_, Y_]], dtype='f'))))
                    # print(ZZ[X_,Y_])

            h = plt.contour(XX, YY, ZZ, colors='black', linestyles='dashed', linewidths=1)
            plt.clabel(h, inline=1, fontsize=10)
            h = plt.contourf(XX, YY, ZZ)
            plt.xlabel('X1')
            plt.xlabel('X2')
            plt.draw()

            plt.pause(0.1)
            plt.clf()





# for reproducibility
torch.manual_seed(777)
if device == 'cuda':
    torch.cuda.manual_seed_all(777)

for param in model.parameters():
    print(param.data)

b=np.array([[3,2,2],[1,1,1],[2,2,2]])
with torch.no_grad():
    hypothesis = model(X)
    predicted = (hypothesis > 0.5).float()
    accuracy = (predicted == Y).float().mean()

    X_test=torch.FloatTensor([[0,0],[1,0],[0.5,0.5]])
    hypothesis2=torch.Tensor.numpy(model(X_test))
    print("[0, 0] : ",hypothesis2[0],"\n[1,0] : ",hypothesis2[1],"\n[0.5, 0.5] : ",hypothesis2[2])


    print('\nHypothesis: ', hypothesis.detach().cpu().numpy(), '\nCorrect: ',
          predicted.detach().cpu().numpy(), '\nAccuracy: ', accuracy.item())









    #cm=plt.cm.get_cmap('viridis')
    #plt.scatter(XXX,YYY,c=ZZ,cmap=cm)
    #plt.show()



    #print(ZZ)
